<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Game Selector</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', sans-serif;
        }
    
        body {
            background: linear-gradient(135deg, #0f0f0f, #1a1a1a);
            color: #e0e0e0;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
    
        .container {
            width: 100%;
            max-width: 1200px;
            text-align: center;
            padding: 20px;
        }
    
        .screen {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #03dac6;
            box-shadow: 0 0 20px rgba(3, 218, 198, 0.5);
            box-sizing: border-box;
        }
    
        .screen.active {
            display: flex;
        }
    
        .game-selection {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 90vw;
            max-height: 80vh;
            padding: 20px;
            overflow-y: auto;
        }
    
        .game-option {
            background: linear-gradient(135deg, #1e1e1e, #2a2a2a);
            border: 2px solid #03dac6;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(3, 218, 198, 0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 150px;
        }
    
        .game-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(3, 218, 198, 0.8), 0 0 40px rgba(3, 218, 198, 0.5);
        }
    
        .game-area {
            width: 90vw;
            height: 80vh;
            border: 2px solid #03dac6;
            margin: 20px auto;
            position: relative;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 20px rgba(3, 218, 198, 0.5);
        }
    
        h1 {
            font-size: 3.5rem;
            margin-bottom: 20px;
            color: #03dac6;
            text-shadow: 0 0 15px rgba(3, 218, 198, 0.8), 0 0 30px rgba(3, 218, 198, 0.5);
        }
    
        p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            max-width: 600px;
            color: #bb86fc;
            text-shadow: 0 0 10px rgba(187, 134, 252, 0.5);
        }
    
        button {
            background: linear-gradient(135deg, #03dac6, #bb86fc);
            color: #121212;
            border: none;
            padding: 12px 24px;
            font-size: 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            box-shadow: 0 0 15px rgba(3, 218, 198, 0.5), 0 0 30px rgba(187, 134, 252, 0.3);
        }
    
        button:hover {
            background: linear-gradient(135deg, #bb86fc, #03dac6);
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(3, 218, 198, 0.8), 0 0 40px rgba(187, 134, 252, 0.5);
        }
    
        .score-display {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5rem;
            color: #03dac6;
            text-shadow: 0 0 10px rgba(3, 218, 198, 0.5);
        }
    
        .death-message {
            font-size: 4rem;
            color: #cf6679;
            animation: fadeInOut 2s infinite;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(207, 102, 121, 0.5), 0 0 30px rgba(207, 102, 121, 0.3);
        }
    
        .final-score {
            font-size: 2rem;
            margin-bottom: 40px;
            color: #03dac6;
            text-shadow: 0 0 10px rgba(3, 218, 198, 0.5);
        }
    
        /* Game-specific styles */
        .target, .snake-segment, .food, .maze-cell, .maze-player, 
        .color-target, .rhythm-note, .platform, .player-character {
            position: absolute;
        }
    
        .target {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, #03dac6, #121212);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(3, 218, 198, 0.5);
        }
    
        .snake-segment {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #03dac6, #bb86fc);
            box-shadow: 0 0 10px rgba(3, 218, 198, 0.5);
        }
    
        .food {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #cf6679, #121212);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(207, 102, 121, 0.5);
        }
    
        .maze {
    position: absolute;
    display: grid;
    gap: 1px;
    background: #1a1a1a;
    border: 2px solid #03dac6;
}
        .rhythm-note {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #03dac6;
            animation: fallDown 3s linear;
        }
    
        @keyframes fadeInOut {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
    
        @keyframes fallDown {
            from { top: -50px; }
            to { top: 100%; }
        }
    
        @media (max-width: 768px) {
            .game-area {
                width: 95vw;
                height: 70vh;
            }
    
            .game-selection {
                grid-template-columns: 1fr;
                width: 95vw;
            }
    
            h1 {
                font-size: 2.5rem;
            }
        }
        /* Add these styles in the <style> section */

.maze-cell {
    border: 1px solid #03dac6;
    background: transparent;
}

.maze-player {
    background: #bb86fc;
    border-radius: 50%;
    box-shadow: 0 0 15px rgba(187, 134, 252, 0.5);
    position: absolute;
    z-index: 2;
    transition: all 0.2s ease;
}

.color-target {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    cursor: pointer;
    position: absolute;
    transition: transform 0.3s ease;
}

.color-target:hover {
    transform: translateY(-50%) scale(1.1) !important;
}

.platform {
    height: 20px;
    background: #03dac6;
    position: absolute;
    border-radius: 4px;
}

.player-character {
    width: 30px;
    height: 30px;
    background: #bb86fc;
    border-radius: 5px;
    position: absolute;
    box-shadow: 0 0 15px rgba(187, 134, 252, 0.5);
}
    </style>
</head>
<body>
    <!-- Title Screen -->
    <div id="titleScreen" class="screen active">
        <h1>Game Challenge</h1>
        <p>Select a specific game or try your luck with a random one! Test your skills and see how high you can score before the inevitable death screen.</p>
        <div class="button-container">
            <button id="startGameBtn">Random Game</button>
            <button id="selectGameBtn">Select Game</button>
        </div>
    </div>
    
    <!-- Game Selection Screen -->
    <div id="gameSelectionScreen" class="screen">
        <h1>Select a Game</h1>
        <div class="game-selection">
            <!-- Add inside the div with class="game-selection" -->
            <div class="game-option" data-game="Flappy Bird">
                <h3>Flappy Bird</h3>
                <p>Navigate through pipes and survive as long as possible</p>
            </div>
<div class="game-option" data-game="Color Match">
    <h3>Color Match</h3>
    <p>Match the target color before time runs out</p>
</div>
<div class="game-option" data-game="Rhythm Master">
    <h3>Rhythm Master</h3>
    <p>Hit the notes at the perfect time</p>
</div>
<div class="game-option" data-game="Platform Jumper">
    <h3>Platform Jumper</h3>
    <p>Jump between platforms without falling</p>
</div>
<div class="game-option" data-game="Math Blast">
    <h3>Math Blast</h3>
    <p>Solve math problems quickly to score points</p>
</div>
            <div class="game-option" data-game="Click The Target">
                <h3>Click The Target</h3>
                <p>Click on shrinking targets before they disappear</p>
            </div>
            <div class="game-option" data-game="Speed Typing">
                <h3>Speed Typing</h3>
                <p>Type words quickly before time runs out</p>
            </div>
            <div class="game-option" data-game="Snake Game">
                <h3>Snake Game</h3>
                <p>Control the snake to eat food without hitting walls or yourself</p>
            </div>
            <div class="game-option" data-game="Memory Match">
                <h3>Memory Match</h3>
                <p>Find matching pairs of cards before time runs out</p>
            </div>
            <div class="game-option" data-game="Falling Objects">
                <h3>Falling Objects</h3>
                <p>Catch the good objects and avoid the bad ones</p>
            </div>
        </div>
        <button id="backToMainBtn">Back to Main Menu</button>
    </div>
    <div class="game-instructions" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 20px; border-radius: 8px; border: 2px solid #03dac6; max-width: 80%; z-index: 1000;">
        <h2 style="color: #03dac6; margin-bottom: 15px;">How to Play</h2>
        <div id="instructionsContent" style="color: #e0e0e0; margin-bottom: 20px;"></div>
        <button id="closeInstructions" style="display: block; margin: 0 auto;">Got it!</button>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <h1 id="gameTitle">Game Title</h1>
        <div class="game-area" id="gameArea"></div>
        <div class="score-display">Score: <span id="scoreValue">0</span></div>
        <button id="quitGameBtn">Quit Game</button>
    </div>
    
    <!-- Death Screen -->
    <div id="deathScreen" class="screen">
        <h1 class="death-message">Game Over</h1>
        <p class="final-score">Your final score: <span id="finalScore">0</span></p>
        <button id="tryAgainBtn">Try Again</button>
        <button id="mainMenuBtn">Main Menu</button>
    </div>

    <script>
        // JavaScript remains unchanged
    </script>

    <script>
        // Game Variables
        let currentGame = null;
        let score = 0;
        let gameInterval = null;
        let gameActive = false;
        
        // DOM Elements
        const titleScreen = document.getElementById('titleScreen');
        const gameSelectionScreen = document.getElementById('gameSelectionScreen');
        const gameScreen = document.getElementById('gameScreen');
        const deathScreen = document.getElementById('deathScreen');
        const gameTitle = document.getElementById('gameTitle');
        const gameArea = document.getElementById('gameArea');
        const scoreValue = document.getElementById('scoreValue');
        const finalScore = document.getElementById('finalScore');
        const startGameBtn = document.getElementById('startGameBtn');
        const selectGameBtn = document.getElementById('selectGameBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const quitGameBtn = document.getElementById('quitGameBtn');
        const tryAgainBtn = document.getElementById('tryAgainBtn');
        const mainMenuBtn = document.getElementById('mainMenuBtn');
        const gameOptions = document.querySelectorAll('.game-option');
        
        
        // Event Listeners
        startGameBtn.addEventListener('click', startRandomGame);
        selectGameBtn.addEventListener('click', () => showScreen(gameSelectionScreen));
        backToMainBtn.addEventListener('click', () => showScreen(titleScreen));
        quitGameBtn.addEventListener('click', showDeathScreen);
        tryAgainBtn.addEventListener('click', () => {
            if (currentGame) {
                startSpecificGame(currentGame);
            } else {
                startRandomGame();
            }
        });
        mainMenuBtn.addEventListener('click', showTitleScreen);
        
        // Add event listeners to game options
        gameOptions.forEach(option => {
            option.addEventListener('click', () => {
                const gameName = option.getAttribute('data-game');
                startSpecificGame(gameName);
            });
        });
        gameOptions.forEach(option => {
    const gameName = option.getAttribute('data-game');
    const instructionsBtn = document.createElement('button');
    instructionsBtn.textContent = "How to Play";
    instructionsBtn.style.fontSize = "0.8rem";
    instructionsBtn.style.padding = "5px 10px";
    instructionsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showInstructions(gameName);
    });
    option.appendChild(instructionsBtn);
});

document.getElementById('closeInstructions').addEventListener('click', () => {
    document.querySelector('.game-instructions').style.display = 'none';
});

function showInstructions(gameName) {
    const instructions = gameInstructions[gameName];
    const instructionsDiv = document.querySelector('.game-instructions');
    const content = document.getElementById('instructionsContent');
    
    content.innerHTML = `
        <h3 style="color: #bb86fc; margin-bottom: 10px;">${instructions.title}</h3>
        <p>${instructions.instructions}</p>
    `;
    
    instructionsDiv.style.display = 'block';
}
        
        // Screen Management Functions
        function showScreen(screen) {
            titleScreen.classList.remove('active');
            gameSelectionScreen.classList.remove('active');
            gameScreen.classList.remove('active');
            deathScreen.classList.remove('active');
            screen.classList.add('active');
        }
        
        function showTitleScreen() {
            showScreen(titleScreen);
            resetGame();
        }
        
        function showGameScreen() {
            showScreen(gameScreen);
        }
        
        function showDeathScreen() {
            showScreen(deathScreen);
            finalScore.textContent = score;
            resetGame();
        }
        
        function resetGame() {
            clearInterval(gameInterval);
            gameActive = false;
            score = 0;
            scoreValue.textContent = score;
            gameArea.innerHTML = '';
        }
        
        // Game Functions
        const gameInstructions = {
    "Click The Target": {
        title: "Click The Target",
        instructions: "Click on the shrinking circular targets before they disappear. Each successful click earns you a point. The targets get smaller over time - if they disappear before you click them, it's game over!"
    },
    "Speed Typing": {
        title: "Speed Typing",
        instructions: "Type the displayed words correctly before time runs out. Each correct word gives you points and adds time. Make a mistake or run out of time, and it's game over! Keep typing to survive longer!"
    },
    "Snake Game": {
        title: "Snake Game",
        instructions: "Control the snake using arrow keys or touch controls. Eat the food to grow longer and score points. Don't hit the walls or yourself! The snake grows longer with each piece of food eaten."
    },
    "Memory Match": {
        title: "Memory Match",
        instructions: "Find matching pairs of cards by flipping them over. Remember card positions and match all pairs before time runs out. Each match earns points, and remaining time adds bonus points!"
    },
    "Falling Objects": {
        title: "Falling Objects",
        instructions: "Move left/right with arrow keys or touch. Catch the good objects (cyan) and avoid the bad ones (red). You have 3 lives. Missing good objects or catching bad ones costs a life!"
    },
    "Flappy Bird": {
        title: "Flappy Bird",
        instructions: "Press spacebar or tap the screen to make the bird fly up. Avoid hitting the pipes and don't fly too high or too low. Each pipe you pass through earns you 10 points. Time your jumps carefully to navigate through the gaps!"
    },
    "Color Match": {
        title: "Color Match",
        instructions: "Click on the color that matches the text color shown. Be quick - you have limited time! Each correct match earns points, but one wrong click ends the game!"
    },
    "Rhythm Master": {
        title: "Rhythm Master",
        instructions: "Press the spacebar when notes reach the hit zone at the bottom. Time your hits perfectly to score points. Miss a note or hit at the wrong time, and it's game over!"
    },
    "Platform Jumper": {
        title: "Platform Jumper",
        instructions: "Press spacebar to jump between platforms. Don't fall off! Land on platforms to stay alive and score points. Falling into the void ends the game!"
    },
    "Math Blast": {
        title: "Math Blast",
        instructions: "Solve math problems by selecting the correct answer from multiple choices. Each correct answer earns points. One wrong answer or running out of time ends the game!"
    }
};

        function getGames() {
    return [
        
        // Existing Games
        {name: "Click The Target", setup: setupClickGame},
        {name: "Speed Typing", setup: setupTypingGame},
        {name: "Snake Game", setup: setupSnakeGame},
        {name: "Memory Match", setup: setupMemoryGame},
        {name: "Falling Objects", setup: setupFallingObjectsGame},
        
        // New Games
        {name: "Flappy Bird", setup: setupMazeGame},
        {name: "Color Match", setup: setupColorGame},
        {name: "Rhythm Master", setup: setupRhythmGame},
        {name: "Platform Jumper", setup: setupPlatformGame},
        {name: "Math Blast", setup: setupMathGame}
    ];
}
        
        // Game Selection
        function startRandomGame() {
            resetGame();
            const games = getGames();
            
            const randomGame = games[Math.floor(Math.random() * games.length)];
            currentGame = randomGame.name;
            gameTitle.textContent = randomGame.name;
            showGameScreen();
            randomGame.setup();
        }
        
        function startSpecificGame(gameName) {
            resetGame();
            const games = getGames();
            const game = games.find(g => g.name === gameName);
            
            if (game) {
                currentGame = game.name;
                gameTitle.textContent = game.name;
                showGameScreen();
                game.setup();
            } else {
                console.error("Game not found:", gameName);
            }
        }
        
        // Game 1: Click The Target
        function setupClickGame() {
            gameActive = true;
            score = 0;
            scoreValue.textContent = score;
            
            const createTarget = () => {
                if (!gameActive) return;
                
                gameArea.innerHTML = '';
                const target = document.createElement('div');
                target.className = 'target';
                
                // Random position
                const maxX = gameArea.clientWidth - 50;
                const maxY = gameArea.clientHeight - 50;
                const x = Math.floor(Math.random() * maxX);
                const y = Math.floor(Math.random() * maxY);
                
                target.style.left = `${x}px`;
                target.style.top = `${y}px`;
                
                target.addEventListener('click', () => {
                    score++;
                    scoreValue.textContent = score;
                    target.remove();
                    createTarget();
                });
                
                gameArea.appendChild(target);
                
                // Target shrinks over time
                let size = 50;
                const shrinkInterval = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(shrinkInterval);
                        return;
                    }
                    
                    size -= 2;
                    target.style.width = `${size}px`;
                    target.style.height = `${size}px`;
                    
                    if (size <= 0) {
                        clearInterval(shrinkInterval);
                        showDeathScreen();
                    }
                }, 100);
            };
            
            createTarget();
        }
        
        // Game 2: Speed Typing
        function setupTypingGame() {
            gameActive = true;
            score = 0;
            scoreValue.textContent = score;
            
            const words = ['javascript', 'coding', 'website', 'developer', 'interactive', 'keyboard', 
                           'challenge', 'function', 'variable', 'computer', 'algorithm', 'program'];
            
            gameArea.innerHTML = `
                <div style="margin-top: 150px">
                    <div class="word-display" id="wordDisplay"></div>
                    <input type="text" id="wordInput" autocomplete="off" autofocus>
                </div>
            `;
            
            const wordDisplay = document.getElementById('wordDisplay');
            const wordInput = document.getElementById('wordInput');
            
            let currentWord = '';
            let timeLeft = 10;
            let timerDisplay;
            
            const newWord = () => {
                currentWord = words[Math.floor(Math.random() * words.length)];
                wordDisplay.textContent = currentWord;
            };
            
            wordInput.addEventListener('input', () => {
                if (wordInput.value === currentWord) {
                    score++;
                    scoreValue.textContent = score;
                    wordInput.value = '';
                    timeLeft += 2; // Add time for correct word
                    newWord();
                }
            });
            
            // Timer
            timerDisplay = document.createElement('div');
            timerDisplay.style.fontSize = '1.5rem';
            timerDisplay.style.marginTop = '20px';
            gameArea.querySelector('div').appendChild(timerDisplay);
            
            newWord();
            wordInput.focus();
            
            gameInterval = setInterval(() => {
                timeLeft -= 0.1;
                timerDisplay.textContent = `Time: ${timeLeft.toFixed(1)}`;
                
                if (timeLeft <= 0) {
                    clearInterval(gameInterval);
                    showDeathScreen();
                }
            }, 100);
        }
        
        // Game 3: Snake Game
        function setupSnakeGame() {
            gameActive = true;
            score = 0;
            scoreValue.textContent = score;
            
            const gridSize = 20;
            const gridWidth = Math.floor(gameArea.clientWidth / gridSize);
            const gridHeight = Math.floor(gameArea.clientHeight / gridSize);
            
            let snake = [
                {x: Math.floor(gridWidth / 2), y: Math.floor(gridHeight / 2)}
            ];
            
            let food = {
                x: Math.floor(Math.random() * gridWidth),
                y: Math.floor(Math.random() * gridHeight)
            };
            
            let direction = 'right';
            let nextDirection = 'right';
            
            // Handle keyboard input
            window.addEventListener('keydown', (e) => {
                if (!gameActive) return;
                
                const key = e.key;
                if (key === 'ArrowUp' && direction !== 'down') nextDirection = 'up';
                if (key === 'ArrowDown' && direction !== 'up') nextDirection = 'down';
                if (key === 'ArrowLeft' && direction !== 'right') nextDirection = 'left';
                if (key === 'ArrowRight' && direction !== 'left') nextDirection = 'right';
            });
            
            // Create touch controls for mobile
            const touchControls = document.createElement('div');
            touchControls.style.display = 'flex';
            touchControls.style.flexWrap = 'wrap';
            touchControls.style.justifyContent = 'center';
            touchControls.style.marginTop = '20px';
            touchControls.style.width = '150px';
            
            const createTouchButton = (text, dir) => {
                const btn = document.createElement('button');
                btn.textContent = text;
                btn.style.margin = '5px';
                btn.style.padding = '10px';
                btn.style.width = '40px';
                btn.style.height = '40px';
                btn.style.display = 'flex';
                btn.style.justifyContent = 'center';
                btn.style.alignItems = 'center';
                
                btn.addEventListener('click', () => {
                    if (dir === 'up' && direction !== 'down') nextDirection = 'up';
                    if (dir === 'down' && direction !== 'up') nextDirection = 'down';
                    if (dir === 'left' && direction !== 'right') nextDirection = 'left';
                    if (dir === 'right' && direction !== 'left') nextDirection = 'right';
                });
                
                return btn;
            };
            
            touchControls.appendChild(document.createElement('div')); // Empty space
            touchControls.appendChild(createTouchButton('↑', 'up'));
            touchControls.appendChild(document.createElement('div')); // Empty space
            touchControls.appendChild(createTouchButton('←', 'left'));
            touchControls.appendChild(document.createElement('div')); // Empty space
            touchControls.appendChild(createTouchButton('→', 'right'));
            touchControls.appendChild(document.createElement('div')); // Empty space
            touchControls.appendChild(createTouchButton('↓', 'down'));
            touchControls.appendChild(document.createElement('div')); // Empty space
            
            const controlContainer = document.createElement('div');
            controlContainer.style.display = 'flex';
            controlContainer.style.justifyContent = 'center';
            controlContainer.style.position = 'absolute';
            controlContainer.style.bottom = '10px';
            controlContainer.style.width = '100%';
            controlContainer.appendChild(touchControls);
            
            gameArea.appendChild(controlContainer);
            
            // Game update function
            const updateSnake = () => {
                if (!gameActive) return;
                
                // Update direction
                direction = nextDirection;
                
                // Calculate new head position
                const head = {...snake[0]};
                
                switch (direction) {
                    case 'up': head.y--; break;
                    case 'down': head.y++; break;
                    case 'left': head.x--; break;
                    case 'right': head.x++; break;
                }
                
                // Check if game over (wall collision or self collision)
                if (
                    head.x < 0 || head.x >= gridWidth || 
                    head.y < 0 || head.y >= gridHeight ||
                    snake.some(segment => segment.x === head.x && segment.y === head.y)
                ) {
                    showDeathScreen();
                    return;
                }
                
                // Add new head
                snake.unshift(head);
                
                // Check if snake ate food
                if (head.x === food.x && head.y === food.y) {
                    // Increase score
                    score++;
                    scoreValue.textContent = score;
                    
                    // Create new food
                    food = {
                        x: Math.floor(Math.random() * gridWidth),
                        y: Math.floor(Math.random() * gridHeight)
                    };
                } else {
                    // Remove tail if no food was eaten
                    snake.pop();
                }
                
                // Draw everything
                gameArea.innerHTML = '';
                gameArea.appendChild(controlContainer);
                
                // Draw snake
                snake.forEach((segment, index) => {
                    const snakeSegment = document.createElement('div');
                    snakeSegment.className = 'snake-segment';
                    snakeSegment.style.left = `${segment.x * gridSize}px`;
                    snakeSegment.style.top = `${segment.y * gridSize}px`;
                    
                    // Make head a different color
                    if (index === 0) {
                        snakeSegment.style.backgroundColor = '#bb86fc';
                    }
                    
                    gameArea.appendChild(snakeSegment);
                });
                
                // Draw food
                const foodElement = document.createElement('div');
                foodElement.className = 'food';
                foodElement.style.left = `${food.x * gridSize}px`;
                foodElement.style.top = `${food.y * gridSize}px`;
                gameArea.appendChild(foodElement);
            };
            
            // Start game loop
            gameInterval = setInterval(updateSnake, 150);
        }
        
        // Game 4: Memory Match
        function setupMemoryGame() {
            gameActive = true;
            score = 0;
            scoreValue.textContent = score;
            
            const symbols = ['★', '♦', '♥', '♣', '♠', '⚡', '❄', '✿'];
            const pairs = [...symbols, ...symbols];
            
            // Shuffle the pairs
            for (let i = pairs.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pairs[i], pairs[j]] = [pairs[j], pairs[i]];
            }
            
            // Create game board
            gameArea.innerHTML = `
                <div class="memory-board"></div>
                <div class="memory-timer">Time: <span id="memoryTimer">60</span></div>
            `;
            
            const board = gameArea.querySelector('.memory-board');
            board.style.display = 'grid';
            board.style.gridTemplateColumns = 'repeat(4, 1fr)';
            board.style.gridGap = '10px';
            board.style.width = '100%';
            board.style.maxWidth = '400px';
            board.style.margin = '0 auto';
            board.style.marginTop = '30px';
            
            const timerDisplay = document.getElementById('memoryTimer');
            let timeLeft = 60;
            let flippedCards = [];
            let matchedPairs = 0;
            
            // Create cards
            pairs.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'memory-card';
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                
                card.style.height = '80px';
                card.style.backgroundColor = '#2d2d2d';
                card.style.borderRadius = '8px';
                card.style.display = 'flex';
                card.style.justifyContent = 'center';
                card.style.alignItems = 'center';
                card.style.fontSize = '2rem';
                card.style.cursor = 'pointer';
                card.style.transition = 'all 0.3s ease';
                card.style.transform = 'rotateY(180deg)';
                card.style.color = 'transparent';
                
                card.textContent = symbol;
                
                card.addEventListener('click', () => {
                    if (!gameActive) return;
                    if (flippedCards.length >= 2) return;
                    if (card.classList.contains('matched')) return;
                    if (flippedCards.some(c => c.dataset.index === card.dataset.index)) return;
                    
                    // Flip card
                    card.style.backgroundColor = '#bb86fc';
                    card.style.transform = 'rotateY(0deg)';
                    card.style.color = '#121212';
                    
                    flippedCards.push(card);
                    
                    if (flippedCards.length === 2) {
                        setTimeout(() => {
                            // Check for match
                            if (flippedCards[0].dataset.symbol === flippedCards[1].dataset.symbol) {
                                flippedCards.forEach(c => {
                                    c.classList.add('matched');
                                    c.style.backgroundColor = '#03dac6';
                                });
                                matchedPairs++;
                                score += 10;
                                scoreValue.textContent = score;
                                
                                // Check for win
                                if (matchedPairs === symbols.length) {
                                    clearInterval(gameInterval);
                                    setTimeout(() => {
                                        score += timeLeft; // Bonus points for remaining time
                                        scoreValue.textContent = score;
                                        showDeathScreen();
                                    }, 1000);
                                }
                            } else {
                                // No match, flip back
                                flippedCards.forEach(c => {
                                    c.style.backgroundColor = '#2d2d2d';
                                    c.style.transform = 'rotateY(180deg)';
                                    c.style.color = 'transparent';
                                });
                            }
                            flippedCards = [];
                        }, 1000);
                    }
                });
                
                board.appendChild(card);
            });
            
            // Timer
            gameInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(gameInterval);
                    setTimeout(() => {
                        showDeathScreen();
                    }, 500);
                }
            }, 1000);
        }
        
        // Game 5: Falling Objects
        function setupFallingObjectsGame() {
            gameActive = true;
            score = 0;
            scoreValue.textContent = score;
            
            gameArea.innerHTML = '';
            
            // Create player
            const player = document.createElement('div');
            player.style.position = 'absolute';
            player.style.bottom = '20px';
            player.style.width = '60px';
            player.style.height = '20px';
            player.style.backgroundColor = '#03dac6';
            player.style.borderRadius = '5px';
            player.style.left = `${gameArea.clientWidth / 2 - 30}px`;
            gameArea.appendChild(player);
            
            // Variables
            let playerX = gameArea.clientWidth / 2 - 30;
            let playerSpeed = 10;
            let objects = [];
            let spawnRate = 1500; // ms
            let spawnTimer = 0;
            let lastFrameTime = 0;
            let lives = 3;
            
            // Create lives display
            const livesDisplay = document.createElement('div');
            livesDisplay.style.position = 'absolute';
            livesDisplay.style.top = '10px';
            livesDisplay.style.left = '10px';
            livesDisplay.style.fontSize = '1.2rem';
            livesDisplay.style.color = '#cf6679';
            livesDisplay.textContent = `Lives: ${lives}`;
            gameArea.appendChild(livesDisplay);
            
            // Handle keyboard input
            const keys = {};
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Touch controls
            let touchStartX = 0;
            gameArea.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
            });
            
            gameArea.addEventListener('touchmove', (e) => {
                const touchX = e.touches[0].clientX;
                const diff = touchX - touchStartX;
                touchStartX = touchX;
                
                playerX += diff;
                
                // Keep player within bounds
                if (playerX < 0) playerX = 0;
                if (playerX > gameArea.clientWidth - 60) playerX = gameArea.clientWidth - 60;
                
                player.style.left = `${playerX}px`;
            });
            
            // Create new falling object
            function createObject() {
                const isGood = Math.random() > 0.3; // 70% chance for good objects
                
                const object = document.createElement('div');
                object.style.position = 'absolute';
                object.style.width = '30px';
                object.style.height = '30px';
                object.style.backgroundColor = isGood ? '#03dac6' : '#cf6679';
                object.style.borderRadius = '50%';
                object.style.top = '0px';
                
                // Random position on X axis
                const x = Math.random() * (gameArea.clientWidth - 30);
                object.style.left = `${x}px`;
                
                // Random speed
                const speed = 3 + Math.random() * 3;
                
                gameArea.appendChild(object);
                
                objects.push({
                    element: object,
                    x,
                    y: 0,
                    speed,
                    isGood
                });
            }
            
            // Game update function
            function updateGame(timestamp) {
                if (!gameActive) return;
                
                // Time delta for smooth animation
                const deltaTime = timestamp - lastFrameTime;
                lastFrameTime = timestamp;
                
                // Move player
                if (keys['ArrowLeft']) {
                    playerX -= playerSpeed;
                }
                if (keys['ArrowRight']) {
                    playerX += playerSpeed;
                }
                
                // Keep player within bounds
                if (playerX < 0) playerX = 0;
                if (playerX > gameArea.clientWidth - 60) playerX = gameArea.clientWidth - 60;
                
                player.style.left = `${playerX}px`;
                
                // Spawn new objects
                spawnTimer += deltaTime;
                if (spawnTimer >= spawnRate) {
                    createObject();
                    spawnTimer = 0;
                    
                    // Increase difficulty over time
                    spawnRate = Math.max(500, spawnRate - 10);
                }
                
                // Update objects
                for (let i = objects.length - 1; i >= 0; i--) {
                    const obj = objects[i];
                    obj.y += obj.speed;
                    obj.element.style.top = `${obj.y}px`;
                    
                    // Check for collision with player
                    if (obj.y + 30 >= gameArea.clientHeight - 30 &&
                        obj.x + 30 > playerX &&
                        obj.x < playerX + 60) {
                        
                        // Remove object
                        gameArea.removeChild(obj.element);
                        objects.splice(i, 1);
                        
                        if (obj.isGood) {
                            // Good object - increase score
                            score += 5;
                            scoreValue.textContent = score;
                        } else {
                            // Bad object - lose a life
                            lives--;
                            livesDisplay.textContent = `Lives: ${lives}`;
                            
                            if (lives <= 0) {
                                gameActive = false;
                                showDeathScreen();
                                return;
                            }
                        }
                    }
                    // Check if object is off screen
                    else if (obj.y > gameArea.clientHeight) {
                        if (obj.isGood) {
                            // Missed a good object - lose a life
                            lives--;
                            livesDisplay.textContent = `Lives: ${lives}`;
                            
                            if (lives <= 0) {
                                gameActive = false;
                                showDeathScreen();
                                return;
                            }
                        }
                        
                        // Remove object
                        gameArea.removeChild(obj.element);
                        objects.splice(i, 1);
                    }
                }
                
                // Continue animation
                if (gameActive) {
                    requestAnimationFrame(updateGame);
                }
            }
            
            // Start game loop
            requestAnimationFrame(updateGame);
        }
        // Add after the last game function
        function setupMazeGame() {
    gameActive = true;
    score = 0;
    scoreValue.textContent = score;

    const bird = {
        x: gameArea.clientWidth * 0.2,
        y: gameArea.clientHeight / 2,
        velocity: 0,
        size: 30
    };

    const gravity = 0.5;
    const jumpForce = -10;
    const pipes = [];
    const pipeWidth = 60;
    const gapHeight = 150;
    const pipeSpeed = 3;

    // Create bird element
    const birdElement = document.createElement('div');
    birdElement.style.position = 'absolute';
    birdElement.style.width = `${bird.size}px`;
    birdElement.style.height = `${bird.size}px`;
    birdElement.style.backgroundColor = '#bb86fc';
    birdElement.style.borderRadius = '50%';
    birdElement.style.boxShadow = '0 0 15px rgba(187, 134, 252, 0.5)';
    birdElement.style.transition = 'transform 0.2s';

    function createPipe() {
        const gapStart = Math.random() * (gameArea.clientHeight - gapHeight - 100) + 50;
        
        const topPipe = document.createElement('div');
        topPipe.style.position = 'absolute';
        topPipe.style.width = `${pipeWidth}px`;
        topPipe.style.height = `${gapStart}px`;
        topPipe.style.backgroundColor = '#03dac6';
        topPipe.style.right = '0';
        topPipe.style.top = '0';
        
        const bottomPipe = document.createElement('div');
        bottomPipe.style.position = 'absolute';
        bottomPipe.style.width = `${pipeWidth}px`;
        bottomPipe.style.height = `${gameArea.clientHeight - gapStart - gapHeight}px`;
        bottomPipe.style.backgroundColor = '#03dac6';
        bottomPipe.style.right = '0';
        bottomPipe.style.bottom = '0';
        
        gameArea.appendChild(topPipe);
        gameArea.appendChild(bottomPipe);
        
        pipes.push({
            x: gameArea.clientWidth,
            topPipe,
            bottomPipe,
            passed: false
        });
    }

    function jump() {
        if (!gameActive) return;
        bird.velocity = jumpForce;
    }

    // Event listeners
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') jump();
    });
    
    gameArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        jump();
    });

    function checkCollision(pipe) {
        const birdRight = bird.x + bird.size;
        const birdLeft = bird.x;
        const pipeLeft = pipe.x;
        const pipeRight = pipe.x + pipeWidth;
        
        // Check if bird is within pipe's x-coordinates
        if (birdRight > pipeLeft && birdLeft < pipeRight) {
            const topPipeHeight = parseInt(pipe.topPipe.style.height);
            const bottomPipeTop = gameArea.clientHeight - parseInt(pipe.bottomPipe.style.height);
            
            // Check if bird hits top or bottom pipe
            if (bird.y < topPipeHeight || bird.y + bird.size > bottomPipeTop) {
                return true;
            }
        }
        return false;
    }

    function update() {
        if (!gameActive) return;

        // Update bird position
        bird.velocity += gravity;
        bird.y += bird.velocity;
        
        // Update bird element
        birdElement.style.top = `${bird.y}px`;
        birdElement.style.left = `${bird.x}px`;
        birdElement.style.transform = `rotate(${bird.velocity * 2}deg)`;

        // Create new pipes
        if (pipes.length === 0 || pipes[pipes.length - 1].x < gameArea.clientWidth - 300) {
            createPipe();
        }

        // Update pipes
        for (let i = pipes.length - 1; i >= 0; i--) {
            const pipe = pipes[i];
            pipe.x -= pipeSpeed;
            pipe.topPipe.style.right = `${gameArea.clientWidth - pipe.x - pipeWidth}px`;
            pipe.bottomPipe.style.right = `${gameArea.clientWidth - pipe.x - pipeWidth}px`;

            // Check for collision
            if (checkCollision(pipe)) {
                gameActive = false;
                showDeathScreen();
                return;
            }

            // Score points when passing pipes
            if (!pipe.passed && pipe.x + pipeWidth < bird.x) {
                pipe.passed = true;
                score += 10;
                scoreValue.textContent = score;
            }

            // Remove off-screen pipes
            if (pipe.x + pipeWidth < 0) {
                gameArea.removeChild(pipe.topPipe);
                gameArea.removeChild(pipe.bottomPipe);
                pipes.splice(i, 1);
            }
        }

        // Check bounds
        if (bird.y < 0 || bird.y + bird.size > gameArea.clientHeight) {
            gameActive = false;
            showDeathScreen();
            return;
        }

        requestAnimationFrame(update);
    }

    // Initialize game
    gameArea.innerHTML = '';
    gameArea.appendChild(birdElement);
    requestAnimationFrame(update);

    // Cleanup function
    return () => {
        window.removeEventListener('keydown', jump);
        gameArea.removeEventListener('touchstart', jump);
    };
}
function setupColorGame() {
    gameActive = true;
    score = 0;
    scoreValue.textContent = score;

    const colors = ['#03dac6', '#bb86fc', '#cf6679', '#ff0266'];
    let targetColor = '';
    let timeLeft = 30;

    const timerDisplay = document.createElement('div');
    timerDisplay.style.position = 'absolute';
    timerDisplay.style.top = '20px';
    timerDisplay.style.left = '20px';
    timerDisplay.style.fontSize = '1.5rem';

    function createTargets() {
        gameArea.innerHTML = '';
        gameArea.appendChild(timerDisplay);

        targetColor = colors[Math.floor(Math.random() * colors.length)];
        
        colors.forEach((color, index) => {
            const target = document.createElement('div');
            target.className = 'color-target';
            target.style.background = color;
            target.style.left = `${(index * 25) + 10}%`;
            target.style.top = '50%';
            target.style.transform = 'translateY(-50%)';

            target.addEventListener('click', () => {
                if (color === targetColor) {
                    score += 10;
                    scoreValue.textContent = score;
                    createTargets();
                } else {
                    showDeathScreen();
                }
            });

            gameArea.appendChild(target);
        });

        const colorDisplay = document.createElement('div');
        colorDisplay.style.position = 'absolute';
        colorDisplay.style.top = '30%';
        colorDisplay.style.width = '100%';
        colorDisplay.style.textAlign = 'center';
        colorDisplay.style.fontSize = '2rem';
        colorDisplay.textContent = 'Match this color!';
        colorDisplay.style.color = targetColor;
        gameArea.appendChild(colorDisplay);
    }

    createTargets();

    gameInterval = setInterval(() => {
        timeLeft--;
        timerDisplay.textContent = `Time: ${timeLeft}`;

        if (timeLeft <= 0) {
            clearInterval(gameInterval);
            showDeathScreen();
        }
    }, 1000);
}

function setupRhythmGame() {
    gameActive = true;
    score = 0;
    scoreValue.textContent = score;

    const hitZone = document.createElement('div');
    hitZone.style.position = 'absolute';
    hitZone.style.bottom = '50px';
    hitZone.style.width = '100%';
    hitZone.style.height = '40px';
    hitZone.style.background = 'rgba(3, 218, 198, 0.2)';

    gameArea.innerHTML = '';
    gameArea.appendChild(hitZone);

    let currentNote = null;
    let noteInPlay = false;

    function createNote() {
        if (!gameActive || noteInPlay) return;

        const note = document.createElement('div');
        note.className = 'rhythm-note';
        note.style.left = `${Math.random() * (gameArea.clientWidth - 40)}px`;
        gameArea.appendChild(note);
        currentNote = note;
        noteInPlay = true;

        note.addEventListener('animationend', () => {
            if (gameActive && noteInPlay) {
                showDeathScreen();
            }
            note.remove();
            noteInPlay = false;
            if (gameActive) {
                setTimeout(createNote, 500); // Add a small delay before next note
            }
        });
    }

    function handleHit() {
        if (!gameActive || !currentNote) return;

        const noteRect = currentNote.getBoundingClientRect();
        const hitRect = hitZone.getBoundingClientRect();

        if (noteRect.bottom >= hitRect.top && noteRect.top <= hitRect.bottom) {
            currentNote.remove();
            noteInPlay = false;
            score += 10;
            scoreValue.textContent = score;
            setTimeout(createNote, 500); // Add a small delay before next note
        } else {
            showDeathScreen();
        }
    }

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            handleHit();
        }
    });

    // Touch controls
    gameArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleHit();
    });

    // Start the game
    createNote();

    // Cleanup
    return () => {
        if (currentNote) {
            currentNote.remove();
        }
        window.removeEventListener('keydown', handleHit);
        gameArea.removeEventListener('touchstart', handleHit);
    };
}
function setupPlatformGame() {
    gameActive = true;
    score = 0;
    scoreValue.textContent = score;

    const player = {
        x: 100,
        y: gameArea.clientHeight - 0, // Start near bottom
        vy: 0,
        jumping: false
    };

    const gravity = 0.5;
    const jumpForce = -12;
    const platforms = [];

    const playerElement = document.createElement('div');
    playerElement.className = 'player-character';

    function createPlatform(x, y, width) {
        const platform = document.createElement('div');
        platform.className = 'platform';
        platform.style.left = `${x}px`;
        platform.style.top = `${y}px`; // Changed from bottom to top
        platform.style.width = `${width}px`;
        platforms.push({ element: platform, x, y, width });
        gameArea.appendChild(platform);
    }

    gameArea.innerHTML = '';
    gameArea.appendChild(playerElement);

    // Create platforms at different heights
    createPlatform(50, gameArea.clientHeight - 50, 100);
    createPlatform(200, gameArea.clientHeight - 100, 100);
    createPlatform(350, gameArea.clientHeight - 150, 100);

    window.addEventListener('keydown', (e) => {
        if (!gameActive) return;

        if (e.key === ' ' && !player.jumping) {
            player.vy = jumpForce;
            player.jumping = true;
        }
        if (e.key === 'ArrowLeft') {
            player.x -= 5;
        }
        if (e.key === 'ArrowRight') {
            player.x += 5;
        }
    });

    function update() {
        if (!gameActive) return;

        player.vy += gravity;
        player.y += player.vy;

        // Check platform collisions
        platforms.forEach(platform => {
            if (player.y >= platform.y - 30 && // Changed collision check
                player.y <= platform.y &&
                player.x + 30 > platform.x && 
                player.x < platform.x + platform.width) {
                player.y = platform.y - 30;
                player.vy = 0;
                player.jumping = false;
            }
        });

        // Update player position
        playerElement.style.top = `${player.y}px`; // Changed from bottom to top
        playerElement.style.left = `${player.x}px`;

        // Check if player fell off the bottom
        if (player.y > gameArea.clientHeight) {
            showDeathScreen();
            return;
        }

        requestAnimationFrame(update);
    }

    update();

    // Cleanup
    return () => {
        window.removeEventListener('keydown', handleKeydown);
    };
}

function setupMathGame() {
    gameActive = true;
    score = 0;
    scoreValue.textContent = score;

    let timeLeft = 30;
    let currentProblem = null;


    function generateProblem() {
        const operators = ['+', '-', '*'];
        const operator = operators[Math.floor(Math.random() * operators.length)];
        const num1 = Math.floor(Math.random() * 12) + 1;
        const num2 = Math.floor(Math.random() * 12) + 1;
        
        let answer;
        switch(operator) {
            case '+': answer = num1 + num2; break;
            case '-': answer = num1 - num2; break;
            case '*': answer = num1 * num2; break;
        }

        return {
            question: `${num1} ${operator} ${num2} = ?`,
            answer: answer,
            options: [
                answer,
                answer + Math.floor(Math.random() * 5) + 1,
                answer - Math.floor(Math.random() * 5) - 1,
                answer * 2
            ].sort(() => Math.random() - 0.5)
        };
    }

    function createProblemDisplay() {
        gameArea.innerHTML = '';
        
        currentProblem = generateProblem();

        const problemText = document.createElement('div');
        problemText.style.fontSize = '2rem';
        problemText.style.marginBottom = '20px';
        problemText.textContent = currentProblem.question;
        gameArea.appendChild(problemText);

        const optionsContainer = document.createElement('div');
        optionsContainer.style.display = 'grid';
        optionsContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
        optionsContainer.style.gap = '10px';

        currentProblem.options.forEach(option => {
            const button = document.createElement('button');
            button.textContent = option;
            button.addEventListener('click', () => {
                if (option === currentProblem.answer) {
                    score += 10;
                    scoreValue.textContent = score;
                    createProblemDisplay();
                } else {
                    showDeathScreen();
                }
            });
            optionsContainer.appendChild(button);
        });

        gameArea.appendChild(optionsContainer);

        const timerDisplay = document.createElement('div');
        timerDisplay.style.position = 'absolute';
        timerDisplay.style.top = '20px';
        timerDisplay.style.right = '20px';
        timerDisplay.textContent = `Time: ${timeLeft}`;
        gameArea.appendChild(timerDisplay);
    }

    createProblemDisplay();

    gameInterval = setInterval(() => {
        timeLeft--;
        const timerDisplay = gameArea.querySelector('div:last-child');
        timerDisplay.textContent = `Time: ${timeLeft}`;

        if (timeLeft <= 0) {
            clearInterval(gameInterval);
            showDeathScreen();
        }
    }, 1000);
}

// Replace the generateMaze function with this corrected version:
function generateMaze(size) {
    const maze = Array(size).fill().map(() => Array(size).fill(1));
    const stack = [{x: 0, y: 0}];
    maze[0][0] = 0;

    while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const neighbors = [
            {x: current.x, y: current.y - 2, dir: {x: 0, y: -1}},
            {x: current.x + 2, y: current.y, dir: {x: 1, y: 0}},
            {x: current.x, y: current.y + 2, dir: {x: 0, y: 1}},
            {x: current.x - 2, y: current.y, dir: {x: -1, y: 0}}
        ].filter(n => 
            n.x >= 0 && n.x < size && 
            n.y >= 0 && n.y < size && 
            maze[n.y][n.x] === 1
        );

        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];
            maze[next.y][next.x] = 0;
            maze[current.y + next.dir.y][current.x + next.dir.x] = 0;
            stack.push(next);
        } else {
            stack.pop();
        }
    }

    return maze; // Make sure to return the maze
}
</script>
</body>
</html>